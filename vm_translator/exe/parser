#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../lib/vm_translator'

CONSTANT_REGEX = /constant (\d+)/
PUSH_REGEX = /^push (.+)$/
ADD_REGEX = /^add$/
SUB_REGEX = /^sub$/
EQ_REGEX = /^eq$/
LT_REGEX = /^lt$/
GT_REGEX = /^gt$/
NEG_REGEX = /^neg$/
AND_REGEX = /^and$/
OR_REGEX = /^or$/
NOT_REGEX = /^not$/

stack = VMTranslator::Stack.new
path = ARGV[0].to_s

def put_start_program
  output = <<~START_PROGRAM
    (START)
    @#{VMTranslator::Stack::STACK_START_RAM_INDEX}
    D=A

    @#{VMTranslator::Stack::STACK_ADDRESS_LOCATION}
    M=D
  START_PROGRAM

  puts output.chomp
end

def put_end_program
  output = <<~END_PROGRAM
    (END)

    @END
    0;JMP
  END_PROGRAM

  puts output.chomp
end

def parse(stack, line)
  if line.match? PUSH_REGEX
    inner_match = line.match(PUSH_REGEX)[1].to_s

    value = parse(stack, inner_match)
    stack.push(value)
  elsif line.match? CONSTANT_REGEX
    result = line.match(CONSTANT_REGEX)[1].to_i

    stack.constant(result)
  elsif line.match? ADD_REGEX
    stack.add
  elsif line.match? SUB_REGEX
    stack.sub
  elsif line.match? EQ_REGEX
    stack.eq
  elsif line.match? LT_REGEX
    stack.lt
  elsif line.match? GT_REGEX
    stack.gt
  elsif line.match? NEG_REGEX
    stack.neg
  elsif line.match? AND_REGEX
    stack.and
  elsif line.match? OR_REGEX
    stack.or
  elsif line.match? NOT_REGEX
    stack.not
  end
end

begin
  put_start_program

  File.readlines(path)
    .map(&:chomp)
    .each { |line| parse(stack, line) }

  put_end_program
rescue StandardError => e
  puts "Error converting VM to ASM: #{e}"
  puts e.backtrace

  exit 1
end

exit 0
