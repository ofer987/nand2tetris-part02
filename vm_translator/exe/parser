#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../lib/vm_translator'

LABEL_REGEX = /^label\s(.+)$/
CONSTANT_REGEX = /constant (\d+)/
LOCAL_REGEX = /local (\d+)/
ARGUMENT_REGEX = /argument (\d+)/
THIS_REGEX = /this (\d+)/
THAT_REGEX = /that (\d+)/
TEMP_REGEX = /temp (\d+)/
POINTER_REGEX = /pointer (\d+)/
STATIC_REGEX = /static (\d+)/
PUSH_REGEX = /^push (.+)$/
POP_REGEX = /^pop (.+)$/
ADD_REGEX = /^add$/
SUB_REGEX = /^sub$/
EQ_REGEX = /^eq$/
LT_REGEX = /^lt$/
GT_REGEX = /^gt$/
NEG_REGEX = /^neg$/
AND_REGEX = /^and$/
OR_REGEX = /^or$/
NOT_REGEX = /^not$/

STACK = VMTranslator::Stack.new
CONSTANT_RAM = VMTranslator::Constant.new
LOCAL_RAM = VMTranslator::Local.new
ARGUMENT_RAM = VMTranslator::Argument.new
THIS_RAM = VMTranslator::This.new
THAT_RAM = VMTranslator::That.new
TEMP_RAM = VMTranslator::Temp.new
POINTER_RAM = VMTranslator::Pointer.new
STATIC_RAM = VMTranslator::Static.new

STATEMENTS = [
  LABEL_REGEX,
  PUSH_REGEX,
  POP_REGEX,
  ADD_REGEX,
  SUB_REGEX,
  EQ_REGEX,
  LT_REGEX,
  GT_REGEX,
  NEG_REGEX,
  AND_REGEX,
  OR_REGEX,
  NOT_REGEX
].freeze

path = ARGV[0].to_s

def put_start_program
  output = <<~START_PROGRAM
    (START)
    @#{VMTranslator::RAM::STACK_RAM_INDEX}
    D=A

    @#{VMTranslator::RAM::STACK_ADDRESS_LOCATION}
    M=D
  START_PROGRAM

  puts output.chomp
end

def put_end_program
  output = <<~END_PROGRAM
    (END)

    @END
    0;JMP
  END_PROGRAM

  puts output.chomp
end

def statement?(line)
  STATEMENTS.each do |statement|
    return true if line.match? statement
  end

  false
end

def parse(line)
  if line.match? PUSH_REGEX
    inner_match = line.match(PUSH_REGEX)[1].to_s

    ram, value = parse(inner_match)
    ram.pop(value)
    STACK.push(value)
  elsif line.match? POP_REGEX
    inner_match = line.match(POP_REGEX)[1].to_s

    ram, value = parse(inner_match)
    STACK.pop(value)
    ram.push(value)
  elsif line.match? CONSTANT_REGEX
    value = line.match(CONSTANT_REGEX)[1].to_i

    [CONSTANT_RAM, value]
  elsif line.match? LOCAL_REGEX
    value = line.match(LOCAL_REGEX)[1].to_i

    [LOCAL_RAM, value]
  elsif line.match? ARGUMENT_REGEX
    value = line.match(ARGUMENT_REGEX)[1].to_i

    [ARGUMENT_RAM, value]
  elsif line.match? THIS_REGEX
    value = line.match(THIS_REGEX)[1].to_i

    [THIS_RAM, value]
  elsif line.match? THAT_REGEX
    value = line.match(THAT_REGEX)[1].to_i

    [THAT_RAM, value]
  elsif line.match? TEMP_REGEX
    value = line.match(TEMP_REGEX)[1].to_i

    [TEMP_RAM, value]
  elsif line.match? POINTER_REGEX
    value = line.match(POINTER_REGEX)[1].to_i

    [POINTER_RAM, value]
  elsif line.match? STATIC_REGEX
    value = line.match(STATIC_REGEX)[1].to_i

    [STATIC_RAM, value]
  elsif line.match? ADD_REGEX
    STACK.asm_reset_to_zero

    first_value = STACK.pop(0)
    STACK.add_operation

    second_value = STACK.pop(0)
    STACK.add_operation

    STACK.push(second_value + first_value)
  elsif line.match? SUB_REGEX
    STACK.asm_reset_to_zero

    first_value = STACK.pop(0)
    STACK.sub_operation

    second_value = STACK.pop(0)
    STACK.sub_operation

    STACK.push(second_value - first_value)
  elsif line.match? EQ_REGEX
    STACK.eq
  elsif line.match? LT_REGEX
    STACK.lt
  elsif line.match? GT_REGEX
    STACK.gt
  elsif line.match? NEG_REGEX
    STACK.neg
  elsif line.match? AND_REGEX
    STACK.asm_reset_to_one

    first_value = STACK.pop(0)
    STACK.and_operation

    second_value = STACK.pop(0)
    STACK.and_operation

    STACK.push(second_value & first_value)
  elsif line.match? OR_REGEX
    STACK.asm_reset_to_zero

    first_value = STACK.pop(0)
    STACK.or_operation

    second_value = STACK.pop(0)
    STACK.or_operation

    STACK.push(second_value | first_value)
  elsif line.match? NOT_REGEX
    STACK.not
  elsif line.match? LABEL_REGEX
    result = line.match(LABEL_REGEX)[1].to_s

    STACK.add_label(result, global_program_counter)
  end
ensure
  global_program_counter += 1 if statement?(line)
end

begin
  global_program_counter = 0
  put_start_program

  File.readlines(path)
    .map(&:strip)
    .each { |line| parse(line) }

  put_end_program
rescue StandardError => e
  puts "Error converting VM to ASM: #{e}"
  puts e.backtrace

  exit 1
end

exit 0
